


#include "stdio.h"
#include "math.h"
#include <iostream>
#include <algorithm>
#include <functional>
#include <list>
#include <map>
#include <memory>
#include <vector>
#include <random>

using namespace std;

auto rng = default_random_engine{};

constexpr int CP = 0;
constexpr int POD = 1;
constexpr int DEPTH = 6;
constexpr float SHIELD_PROB = 10;
constexpr int MAX_THRUST = 200;

inline int fastrand() {
    static unsigned int g_seed = 42;
    g_seed = (214013 * g_seed + 2531011);
    return (g_seed >> 16) & 0x7FFF;
}

inline int rnd(int b) {
    return fastrand() % b;
}

inline int rnd(int a, int b) {
    return a + rnd(b - a + 1);
}

struct Genotype
{
    float score = -1;
    int thrusts[DEPTH * 2]{};
    float angles[DEPTH * 2]{};
};

class GeneticAlgorithm {
public:
	typedef std::map<std::shared_ptr<Genotype>, double> GenotypeScoreMap;
public:
	/**
	* Constructor
	*
	* @param fitnessFunction
	*		Evaluate a candidate. During the selection phase, only the candidates with the highest score will be retained
	*       return the double value representing the quality of a candidate. The higher the better.
	* @param generator
	*		an implementation of a generator in charge of randomly generating new candidates
	* @param merger
	*		an implementation of a merger in charge of creating a new genotype from two already existing genotype
	* @param mutator
	*		an implementation of a mutator in charge of creating a new genotype from an existing genotype but modifying some characteristics
	*/
	GeneticAlgorithm(
		std::function<double(const Genotype&)> fitnessFunction,
		std::function<Genotype()> generator,
		std::function<Genotype(const Genotype&, const Genotype&)> merger,
		std::function<Genotype(const Genotype&)> mutator) :

		m_fitnessFunction(fitnessFunction),
		m_generator(generator),
		m_merger(merger),
		m_mutator(mutator),
		m_cachedScores(),
		m_candidates(),
		m_evaluations(0),
		m_random(0)
	{
	}

	/**
	* @return
	* The current best genotype that has been found during the iterations
	*/
	Genotype best() const {
		return *m_candidates[0];
	}

	/**
	* Clear the candidate list and use the generator to generate a fixed number of genotypes
	* Do not use it between iterations, or you will lose all the previous iterations results!
	*
	* @param initialPoolSize
	*	the number of genotype to be generated
	*/
	void initialize(int initialPoolSize) {
		m_candidates.clear();
		addRandomCandidates(initialPoolSize);
	}

	/**
	* Performs a fixed number of iterations.
	* Each iteration will do successively:
	*    - add iterationAdditionalRandomGenerated randomly generated candidates
	*    - generate a mergedNumber from the merge process with two candidates that has been randomly selected
	* 	 - mutate a mutatedNumber of randomly selected candidates
	*    - evaluate all the instances quality and retain only the selectionNumber best
	* @param numberOfIterations
	* 		the number of iterations to perform
	* @param iterationAdditionalRandomGenerated
	* 		the number of fully random candidate that will be generated
	* @param selectionNumber
	*      the number of candidates that will be kept for the next iterations
	* @param mergedNumber
	* 		the number of candidate to be generated from a merge of randomly selected parents
	* @param mutatedNumber
	* 		the number of candidates to be generated by mutation of randomly selected candidates
	*/
	void iterate(int numberOfIterations, int iterationAdditionalRandomGenerated, int selectionNumber, int mergedNumber, int mutatedNumber) {
		for (int i = 0; i < numberOfIterations; i++) {
			runOneIteration(iterationAdditionalRandomGenerated, selectionNumber, mergedNumber, mutatedNumber);
		}
	}

	/**
	* Allows you to add in the candidates an already defined genotype you already know is valuable
	* Hint: this instance might come from previous iterations and you want to continue with it
	*
	* @param reference
	*	the instance to be added to the candidate list
	*/
	void addReference(const Genotype& reference) {
		m_candidates.push_back(std::make_shared<Genotype>(reference));
	}
	/**
	* returns the number of evaluations performed so far.
	*/
	int getEvaluations() const {
		return m_evaluations;
	}
private:

	void computeScores() {
		GenotypeScoreMap scores;

		for (const std::shared_ptr<Genotype>& candidate : m_candidates) {
			if (m_cachedScores.find(candidate) != m_cachedScores.end()) {
				scores[candidate] = m_cachedScores[candidate];
			}
			else {
				double score = m_fitnessFunction(*candidate);
				m_evaluations++;
				scores[candidate] = score;
				m_cachedScores[candidate] = score;
			}
		}
		m_cachedScores.clear();
		m_cachedScores = scores;
	}

	void dropUnselected(int selectionNumber) {
		m_candidates.erase(m_candidates.begin() + selectionNumber, m_candidates.end());
	}
	void addRandomCandidates(int initialPoolSize) {
		for (int i = 0; i < initialPoolSize; i++) {
			m_candidates.push_back(std::make_shared<Genotype>(m_generator()));
		}
	}

	void merge(int mergedNumber) {
		for (int i = 0; i < mergedNumber; i++) {
			int firstIndex = (2 * i) % m_candidates.size();
			int secondIndex = (2 * i + 1) % m_candidates.size();

			m_candidates.push_back(std::make_shared<Genotype>(m_merger(*m_candidates[firstIndex], *m_candidates[secondIndex])));
		}
	}

	void mutate(int mutatedNumber) {
		for (int i = 0; i < mutatedNumber; i++) {
			m_candidates.push_back(std::make_shared<Genotype>(m_mutator(*m_candidates[i])));
		}
	}

	double runOneIteration(int iterationAdditionalRandomGenerated, int selectionNumber, int mergedNumber, int mutatedNumber) {
		addRandomCandidates(iterationAdditionalRandomGenerated);
		shuffle();
		merge(mergedNumber);
		shuffle();
		mutate(mutatedNumber);
		computeScores();
		sortByScore();
		dropUnselected(selectionNumber);
		return m_cachedScores[m_candidates[0]];
	}
	void sortByScore() {
		std::sort(m_candidates.begin(), m_candidates.end(), [&](const std::shared_ptr<Genotype>& g1, const std::shared_ptr<Genotype>& g2) {
			double v1 = m_cachedScores.find(g1)->second;
			double v2 = m_cachedScores.find(g2)->second;

			return v1 > v2;
			});
	}
	void shuffle() {
		std::shuffle(m_candidates.begin(), m_candidates.end(), m_random);
	}
private:
	std::function<double(const Genotype&)> m_fitnessFunction;
	std::function<Genotype()> m_generator;
	std::function<Genotype(const Genotype&, const Genotype&)> m_merger;
	std::function<Genotype(const Genotype&)> m_mutator;
	GenotypeScoreMap m_cachedScores;
	std::vector<std::shared_ptr<Genotype>> m_candidates;
	int m_evaluations;
	std::default_random_engine m_random;
};

class Combination {
public:
	Combination(Genotype)
	{}




};


int main()
{
	Combination genetic;

    return 0;

    



}

