


#include "stdio.h"
#include "math.h"
#include <iostream>
#include <algorithm>
#include <functional>
#include <list>
#include <map>
#include <memory>
#include <vector>
#include <random>


using namespace std;

auto rng = default_random_engine{};

constexpr int CP = 0;
constexpr int POD = 1;
constexpr int DEPTH = 6;
constexpr float SHIELD_PROB = 10;
constexpr int MAX_THRUST = 200;

static int m_generatorValue = 0;
std::mt19937 m_pseudoRandom(0);

inline int fastrand() {
    static unsigned int g_seed = 42;
    g_seed = (214013 * g_seed + 2531011);
    return (g_seed >> 16) & 0x7FFF;
}

inline int rnd(int b) {
    return fastrand() % b;
}

inline int rnd(int a, int b) {
    return a + rnd(b - a + 1);
}

template<typename Genotype>

class GeneticAlgorithm {
public:
	typedef std::map<std::shared_ptr<Genotype>, double> GenotypeScoreMap;
public:
	/**
	* Constructor
	*
	* @param fitnessFunction
	*		Evaluate a candidate. During the selection phase, only the candidates with the highest score will be retained
	*       return the double value representing the quality of a candidate. The higher the better.
	* @param generator
	*		an implementation of a generator in charge of randomly generating new candidates
	* @param merger
	*		an implementation of a merger in charge of creating a new genotype from two already existing genotype
	* @param mutator
	*		an implementation of a mutator in charge of creating a new genotype from an existing genotype but modifying some characteristics
	*/
	GeneticAlgorithm(
		std::function<double(const Genotype&)> fitnessFunction,
		std::function<Genotype()> generator,
		std::function<Genotype(const Genotype&, const Genotype&)> merger,
		std::function<Genotype(const Genotype&)> mutator) :

		m_fitnessFunction(fitnessFunction),
		m_generator(generator),
		m_merger(merger),
		m_mutator(mutator),
		m_cachedScores(),
		m_candidates(),
		m_evaluations(0),
		m_random(0)
	{
	}

	/**
	* @return
	* The current best genotype that has been found during the iterations
	*/
	Genotype best() const {
		return *m_candidates[0];
	}

	/**
	* Clear the candidate list and use the generator to generate a fixed number of genotypes
	* Do not use it between iterations, or you will lose all the previous iterations results!
	*
	* @param initialPoolSize
	*	the number of genotype to be generated
	*/
	void initialize(int initialPoolSize) {
		m_candidates.clear();
		addRandomCandidates(initialPoolSize);
	}

	/**
	* Performs a fixed number of iterations.
	* Each iteration will do successively:
	*    - add iterationAdditionalRandomGenerated randomly generated candidates
	*    - generate a mergedNumber from the merge process with two candidates that has been randomly selected
	* 	 - mutate a mutatedNumber of randomly selected candidates
	*    - evaluate all the instances quality and retain only the selectionNumber best
	* @param numberOfIterations
	* 		the number of iterations to perform
	* @param iterationAdditionalRandomGenerated
	* 		the number of fully random candidate that will be generated
	* @param selectionNumber
	*      the number of candidates that will be kept for the next iterations
	* @param mergedNumber
	* 		the number of candidate to be generated from a merge of randomly selected parents
	* @param mutatedNumber
	* 		the number of candidates to be generated by mutation of randomly selected candidates
	*/
	void iterate(int numberOfIterations, int iterationAdditionalRandomGenerated, int selectionNumber, int mergedNumber, int mutatedNumber) {
		for (int i = 0; i < numberOfIterations; i++) {
			runOneIteration(iterationAdditionalRandomGenerated, selectionNumber, mergedNumber, mutatedNumber);
		}
	}

	/**
	* Allows you to add in the candidates an already defined genotype you already know is valuable
	* Hint: this instance might come from previous iterations and you want to continue with it
	*
	* @param reference
	*	the instance to be added to the candidate list
	*/
	void addReference(const Genotype& reference) {
		m_candidates.push_back(std::make_shared<Genotype>(reference));
	}
	/**
	* returns the number of evaluations performed so far.
	*/
	int getEvaluations() const {
		return m_evaluations;
	}
private:

	void computeScores() {
		GenotypeScoreMap scores;

		for (const std::shared_ptr<Genotype>& candidate : m_candidates) {
			if (m_cachedScores.find(candidate) != m_cachedScores.end()) {
				scores[candidate] = m_cachedScores[candidate];
			}
			else {
				double score = m_fitnessFunction(*candidate);
				m_evaluations++;
				scores[candidate] = score;
				m_cachedScores[candidate] = score;
			}
		}
		m_cachedScores.clear();
		m_cachedScores = scores;
	}

	void dropUnselected(int selectionNumber) {
		m_candidates.erase(m_candidates.begin() + selectionNumber, m_candidates.end());
	}
	void addRandomCandidates(int initialPoolSize) {
		for (int i = 0; i < initialPoolSize; i++) {
			m_candidates.push_back(std::make_shared<Genotype>(m_generator()));
		}
	}

	void merge(int mergedNumber) {
		for (int i = 0; i < mergedNumber; i++) {
			int firstIndex = (2 * i) % m_candidates.size();
			int secondIndex = (2 * i + 1) % m_candidates.size();

			m_candidates.push_back(std::make_shared<Genotype>(m_merger(*m_candidates[firstIndex], *m_candidates[secondIndex])));
		}
	}

	void mutate(int mutatedNumber) {
		for (int i = 0; i < mutatedNumber; i++) {
			m_candidates.push_back(std::make_shared<Genotype>(m_mutator(*m_candidates[i])));
		}
	}

	double runOneIteration(int iterationAdditionalRandomGenerated, int selectionNumber, int mergedNumber, int mutatedNumber) {
		addRandomCandidates(iterationAdditionalRandomGenerated);
		shuffle();
		merge(mergedNumber);
		shuffle();
		mutate(mutatedNumber);
		computeScores();
		sortByScore();
		dropUnselected(selectionNumber);
		return m_cachedScores[m_candidates[0]];
	}
	void sortByScore() {
		std::sort(m_candidates.begin(), m_candidates.end(), [&](const std::shared_ptr<Genotype>& g1, const std::shared_ptr<Genotype>& g2) {
			double v1 = m_cachedScores.find(g1)->second;
			double v2 = m_cachedScores.find(g2)->second;

			return v1 > v2;
			});
	}
	void shuffle() {
		std::shuffle(m_candidates.begin(), m_candidates.end(), m_random);
	}
private:
	std::function<double(const Genotype&)> m_fitnessFunction;
	std::function<Genotype()> m_generator;
	std::function<Genotype(const Genotype&, const Genotype&)> m_merger;
	std::function<Genotype(const Genotype&)> m_mutator;
	GenotypeScoreMap m_cachedScores;
	std::vector<std::shared_ptr<Genotype>> m_candidates;
	int m_evaluations;
	std::default_random_engine m_random;
};

class Combination {
public:
	Combination(int first, int second, int third, int fourth) : m_first(first), m_second(second), m_third(third), m_fourth(fourth) {
	}

	bool operator<(const Combination& other) const {
		if (m_first == other.m_first) {
			if (m_second == other.m_second) {
				if (m_third == other.m_third) {
					return m_fourth < other.m_fourth;
				}
				return m_third < other.m_third;
			}
			return m_second < other.m_second;
		}
		return m_first < other.m_first;
	}

	bool operator==(const Combination& other) const {
		return m_first == other.m_first && m_second == other.m_second && m_third == other.m_third && m_fourth == other.m_fourth;
	}

	static Combination newInstance() {
		m_generatorValue = (m_generatorValue + 1) % 9;
		return Combination(m_generatorValue, m_generatorValue, m_generatorValue, m_generatorValue);
	}

	double evaluate(const Combination& toBeFound) const {
		double result = 0;

		if (m_first == toBeFound.m_first) {
			result += 10 + m_first;
		}
		if (m_second == toBeFound.m_second) {
			result += 10 + m_second;
		}
		if (m_third == toBeFound.m_third) {
			result += 10 + m_third;
		}
		if (m_fourth == toBeFound.m_fourth) {
			result += 10 + m_fourth;
		}

		return result;
	}
	Combination merge(const Combination& other) const {
		return Combination(
			randomBoolean() ? m_first : other.m_first,
			randomBoolean() ? m_second : other.m_second,
			randomBoolean() ? m_third : other.m_third,
			randomBoolean() ? m_fourth : other.m_fourth);
	}

	Combination mutate() const {
		return Combination(m_first, m_second, m_third, m_fourth + 1);
	}
	std::ostream& operator<<(std::ostream& os)
	{
		os << "C[" << m_first << m_second << m_third << m_fourth << "]";
		return os;
	}
private:
	bool randomBoolean() const {
		return m_pseudoRandom() % 2 == 0;
	}
public:
	int m_first;
	int m_second;
	int m_third;
	int m_fourth;
};


int main()
{
	
	Combination toBeFound(5, 3, 4, 5);
	GeneticAlgorithm<Combination>
		algo([toBeFound](const Combination& c)
			{
				return c.evaluate(toBeFound);
			},
		[]()
			{
				return Combination::newInstance();
			},

		[]
			(const Combination& first, const Combination& second)
			{
				return first.merge(second);
			},
		[](const Combination& c)
			{
				return c.mutate();
			});


	algo.initialize(9);
	algo.iterate(100, 5, 20, 20, 20);

	Combination bestGene{ algo.best() };

	cout << bestGene.m_first;
	cout << bestGene.m_second;
	cout << bestGene.m_third;
	cout << bestGene.m_fourth;

	
	

    return 0;

    



}

